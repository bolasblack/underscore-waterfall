// Generated by CoffeeScript 1.3.3
(function() {
  var funcHolder,
    __slice = [].slice;

  funcHolder = function(originArgs) {
    return function() {
      var args, callback, _i;
      args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), callback = arguments[_i++];
      return callback.apply(null, [null].concat(__slice.call(originArgs)));
    };
  };

  _.mixin({
    waterfall: function(fn) {
      var cacheArgs, callback, calls, metaMethods, stacks, start, thenArgs;
      stacks = {};
      calls = {};
      metaMethods = ["then", "done", "fail", "anyway"];
      thenArgs = [];
      cacheArgs = function(args) {
        args = _(args).toArray();
        if (args.length === 0) {
          return thenArgs.push(void 0);
        } else if (args.length === 1) {
          return thenArgs.push(args[0]);
        } else {
          return thenArgs.push(args);
        }
      };
      start = function() {
        cacheArgs(arguments);
        return fn.apply(null, __slice.call(arguments).concat([callback]));
      };
      callback = function() {
        var args, err, thenFn;
        err = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        if (err) {
          calls.fail(err);
          calls.anyway(err);
          return;
        }
        if (stacks.then.length) {
          cacheArgs(args);
          thenFn = stacks.then.shift();
          if (typeof thenFn === "function") {
            thenFn.apply(null, __slice.call(args).concat([callback]));
          }
          return;
        }
        calls.done.apply(calls, thenArgs);
        return calls.anyway.apply(calls, [null].concat(__slice.call(thenArgs)));
      };
      _(metaMethods).forEach(function(method) {
        var _ref;
        if ((_ref = stacks[method]) == null) {
          stacks[method] = [];
        }
        start[method] = function(callback) {
          if (_(callback).isFunction()) {
            stacks[method].push(callback);
          } else if (callback) {
            stacks[method].push(funcHolder(_(arguments).toArray()));
          }
          return this;
        };
        return calls[method] = function() {
          var stack, _results;
          stack = stacks[method];
          if (stack == null) {
            return;
          }
          _results = [];
          while (stack.length) {
            fn = stack.shift();
            if (method === "then") {
              _results.push(typeof fn === "function" ? fn.apply(null, __slice.call(arguments).concat([callback])) : void 0);
            } else {
              _results.push(typeof fn === "function" ? fn.apply(null, arguments) : void 0);
            }
          }
          return _results;
        };
      });
      return start;
    }
  });

}).call(this);
